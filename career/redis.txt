redis:基于内存高速,LUA脚本整体执行原子性
	调优:数据量相同情况下K,V的长度大操作效率越慢(保存的字段是否都要用、可进行字段的拆分)
		lazy free(延时删除):使用BIO(background I/O)单独一条线程处理,减少删除对redis主线程的阻塞,可通过配置文件进行实现,建议开启lazyfree-lazy-flush、-expire、-server-del
		根据业务需要设置合理过期时间
		尽可能少的在redis中进行并集、交集、排序的操作(放在逻辑代码处执行)
		开启慢日志查询:slow-log-slower-than 来配置记录阈值时间(单位毫秒)
		根据业务可以使用pipeline进行批处理,减少与redis的交互时间
			通过Jedis实例得到Pipeline对象建立链接,set方法将所有的command命令刷入输出流通过sync统一调用flush命令将消息发出
		配置hz 10(默认值推荐使用),避免大量数据同时消失造成缓存雪崩


使用redis缓存:
	解决缓存穿透:空结果缓存
	解决缓存雪崩:设置过期时间
	解决缓存击穿:加锁
	缓存数据一致性:
		双写模式:写数据库更新缓存
		失效模式:写数据库删除缓存(推荐)
			当高并发时,要删除的缓存数据被读到会出现脏数据:将操作放入MQ队列但是性能直线下降违背了使用缓存的目的,性能不升反降
			缓存数据+过期时间可以解决大部分业务对缓存的要求:缓存的数据本身就不要求实时性是不常改变的只是读频繁
			不应该过度的设计增加系统的复杂程度,应根据业务结合性能和数据一致性考虑不同的设计方案

lua脚本:原子性、高性能、逻辑可控
持久化:
	RDB:快照持久化文件
		save:阻塞方式进行持久化
		bgsave:从主线程fork出一个子线程,是非阻塞的(可通过配置文件进行配置:满足时间内key变化的次数就触发)
		save 900 1 	---- 900s内变化一次触发
		save 300 10 ---- 300s内变化10次触发
	AOF:通过保存redis服务器执行的写命令(默认关闭,需要开启配置)
		文件同步:保证集群的一致性(always、everysec推荐使用性能可靠性居中、no)
		文件重写压缩:降低AOF文件所占磁盘空间大小,同时提升服务器启动性能(不必要的命令不必执行)
	RDB、AOF一般会同时使用,保证数据的可靠性